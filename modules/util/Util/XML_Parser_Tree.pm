
=head1 NAME

  Util::XML_Parser_Tree

=head2 DESCRIPTION

Utility functions for structures generated by XML::Parser in tree mode.
Maybe they exist elsewhere, but I didn't find that...

=cut

package Util::XML_Parser_Tree;

use strict;

use Data::Dumper;
$Data::Dumper::Indent= 1;

my %tlt=
(
  '&' => '&amp;',
  '<' => '&lt;',
  '>' => '&gt;',
  # "\x{7ec}" => '&#x2028
);

sub tlt_chr
{
  my $c= shift;
  # "\u2028" => '&#x2028;', # TODO: that needs special treatment

  if (exists ($tlt{$c})) { return $tlt{$c}; }
  if ((my $oc= ord($c)) >= 0x0100)
  {
    my $res= sprintf ('&#x%04x;', $oc);
    # print "UTF8ENT: c=[$c] => oc=[$oc] => res=[$res]\n";
    return $res;
  }
  $c;
}

sub tlt_str
{
  my $s= shift;
  $s=~ s#([&<>\x{0100}-\x{1ffff}])#tlt_chr($1)#ge;

  $s;
}

sub attr_to_string
{
  my $attr= shift;
  join (' ', map { $_ . '="' . $attr->{$_} . '"' } sort keys %$attr);
}

sub to_string
{
  my $s;
  while (@_)
  {
    my $tag= shift;
    my $val= shift;

    # print "tag=[$tag] val=[$val]\n";

    if ($tag eq '0')
    {

      $s .= tlt_str ($val);
    }
    else
    {
      my @val= @$val;
      my $attr= attr_to_string (shift (@val));
      my $s2= to_string (@val);

      # print "tag=[$tag]\n"; print "attr=[$attr]\n"; print "s2=[$s2]\n"; 

      $s .= '<' . $tag;
      $s .= ' ' . $attr if ($attr);
      $s .= '>' . $s2 . '</'. $tag . '>';
    }
  }

  $s;
}

1;

